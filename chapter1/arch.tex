\section{Архитектура системы}

Подходящая архитектура для такой задачи была предложена мной в одной из прошлых
работ\cite{polshakovinject}. Вся работа системы может быть рассмотрена в 3х
частях:

\begin{enumerate}
    \item регистрация изменений в элементах приложения;
    \item посылка команды;
    \item активация элемента.
\end{enumerate}

Рассмотрим детально каждую часть.

\subsection{Регистрация нового элемента}

При запуске приложения, в него внедряется подгружаемый модуль, который
переопределяет некоторые функции библиотеки Qt. Благодаря механизму работы
загрузчика, целевое приложение будет на самом деле вызывать поддельные
функции, вместо реальных.

Когда приложение создает элемент интерфейса или меняет описание уже
существующего происходит вызов соответствующей функции, которую мы
перехватываем. После этого наша библиотека посылает на сервер информацию
о новом элементе или об изменении старого.

Когда все дополнительные действия сделаны, библиотека должны обеспечить
стандартное поведение функции, которую она подменила. Для этого, используя
механизмы загрузчика, она получает адрес настоящей функции и передает
управление Qt. Графическая библиотека в свою очередь занимается формированием
изображения и передает его на отрисовку в графическую подсистему X11.

На рис.~\ref{fig:create-elem} изображена диаграмма последовательности для
этой процедуры.

\begin{figure}[h]
	\centering
	\input{schemes/create-element}
	\caption{Диаграмма последовательности регистрации
		изменений}\label{fig:create-elem}
\end{figure}

\subsection{Посылка команды}

На рис.~\ref{fig:send-command} изображена диаграмма последовательности для
посылки команды. Рассмотрим её детально.

Пользователь, когда ему нужно, вызывает палитру команд и выбирает то, что
его интересует. После этого приложение управления вызывает функцию на стороне
сервера для активации команды. Сервер через сокет передает команду библиотеке,
но она не может выступать инициатором действия, поэтому сервер посылает событие
активации окна графической подсистеме. Это должно заставить систему послать
событие приложению.

\begin{figure}[h]
	\centering
	\input{schemes/send-command}
	\caption{Диаграмма последовательности посылки
		команды}\label{fig:send-command}
\end{figure}

\subsection{Активация элемента}

Когда X11 получает от сервера сообщение о том, что окно должно быть
активировано, он информирует об этом графическую библиотеку. Пользовательское
приложение, которое использует Qt в качестве графической библиотеки,
передает основное управление самому фреймворку, поэтому приемом сообщений
занимается именно он.

Qt попытается передать приложению событие отрисовки. Его сможет перехватить
подгруженный модуль и в этот момент выполнить дополнительные действия "---
активацию элемемента. Кроме активации элемента мы передаем событие в
приложение, чтобы обеспечить стандартное поведение. Активация элемента
производится штатными средствами Qt. Для каждого объекта способ активации
свой.

На рис.~\ref{fig:activate-elem} изображена диаграмма последовательности для
процесса активации элемента.

\begin{figure}[h]
	\centering
	\input{schemes/activate-element}
	\caption{Диаграмма последовательности активации
		элемента}\label{fig:activate-elem}
\end{figure}

\iffalse
\begin{enumerate}
    \item Перехват функции создания элемента интерфейса
    \item Оповещение о создании элемента
    \item Вызов оригинальной функции графической библиотеки
    \item Отображение элемента управления
    \item Передача информации об элементе приложению управления
    \item Отображение палитры команд
    \item Выбор команды
    \item Вызов функции для выполнения команды
    \item Передача команды к выполнению
    \item Вызов функции активации окна целевого приложения
    \item Активация окна
    \item Перехват функции обработки события
    \item Вызов функции обработки события
    \item Вызов функции для выполнения команды
    \item Выполнение команды
\end{enumerate}

\begin{figure}
	\centering
	\input{schemes/arch} \\
	\caption{Общий обзор архитектуры}\label{fig:arch}
\end{figure}

\fi

\chapter{Анализ задачи}

\section{Обзор существующих реализаций палитр команд}

Впервые палитра команд появилась 1 июля 2011 году в редакторе Sublime Text
2~\cite{sublimetext2changelog}. Вслед за этим подобный функционал был реализован
в некоторых других программах. Таких как:
\begin{itemize}
	\item Atom\cite{atom},
	\item VSCode\cite{vscode},
	\item JupyterLab\cite{jupyterlab}.
\end{itemize}

Но это были лишь единичные случаи. В апреле 2017 года появилась альфа версия
приложения Plotinus\cite{plotinus}, которое позволяет добавлять палитру команд в
любое приложение, которое написано с использованием графической библиотеки GTK.

\begin{figure}
	\includegraphics[width=\textwidth]{vscode}
	\caption{VSCode}
\end{figure}

\begin{figure}
	\includegraphics[width=\textwidth]{SublimeText}
	\label{sublimetext}
	\caption{Sublime Text}
\end{figure}

\begin{figure}
	\includegraphics[width=\textwidth]{Plotinus}
	\caption{Plotinus}
\end{figure}


\section{Общий анализ}

Система управления должна позволять контролировать множество приложений. Для её
реализации лучше всего подходит клиент-серверная архитектура. Для каждого
целевого приложения будет запускаться отдельный клиент, который будет заниматься
сбором информации об элементах управления и передавать её на сервер.

В качестве сервера будет выступать приложение, которое запускает целевые
приложения вместе с клиентами. После этого сервер принимает входяще соединение
от клиента и отображающее окно поиска элемента для текущего активного окна.

Для удобной работы окно поиска должно отображаться окно поверх работающего
приложения. И в нем должен производится нечеткий поиск.

\subsection{Добавление логики в стороннее приложение}

Разработчики любого приложения не могут учесть желания и капризы всех
пользователей. Благодаря этому приложения не прервращаются в комбайны, которые
невозможно было бы поддерживать. Разработчики могут убрать какую-то деталь,
которая нужна малому проценту людей. Ведь надо тратить время на исправление
ошибок в ней. А иногда эти специфичные функции могут даже замедлять работу всего
приложения. В таком случае пользователи могут захотеть добавить какую-то
дополнительную логику или функцию в основное приложение.

Подходы делятся на два типа:
\begin{itemize}
	\item добавление функции на этапе сборки приложения;
	\item добавление функции в момент выполнения программы.
\end{itemize}

Целью данной работы является добавление функциональности в максимальную группу
приложений. Первый же подход исключает такую возможность для приложений с
закрытым исходным кодом. К тому же при первым подходом может пользоваться только
квалифицированный пользователь. И то, ему пришлось бы пересобирать каждое
приложение в которое он хотел бы добавить нужную функциональность.

Программный модуль подключаемый к уже существующему приложению называется
плагином. Для добавления возможности подключения плагинов разработчики программы
должны или написать свою систему плагинов или воспользоваться готовой. Так,
например, библиотека GTK, начиная с третьей версии, предоставляет возможность
запускать приложения с дополнительными модулями, которые могут расширять
функциональность приложения. Этим воспользовались разработчики библиотеки
Plotinus, реализовав возможность добавления палитры команд в любое приложение,
использующее GTK3.

Что интересно, Qt предоставляет возможность встраивать дополнительную
функциональность в приложение, но для этого оно должно иметь специальный код по
загрузке дополнительных модулей, который в большинстве случаев не используется
(для подтверждения можно сравнить число github репозиториев использующих
Qt\cite{githubqt} и использующих функцию Qt для работы с
плагинами\cite{githubqpluginloader}. Соотношение примерно 1:100).

Кроме штатных средств добавления функционала на уровне приложения есть и более
низкоуровневые. Так например в Windows есть функция автоматизации
интерфейса (UI Automation)\cite{windowsuiautomation}, которая изначально была
добавлена для увеличения доступности приложений людям с ограниченными
возможностями. Этот же функционал не такой богатый, как функционал плагинов
(тут есть возможность работы только с видимыми элементами интерфейса), но зато
доступен для любого приложения, использующего стандартные элементы управления.
В случае использования Linux, к сожалению, нет такой возможности на уровне ОС
или графической оболочки.

\subsection{Внедрение модуля}

Рассмотрим в общих чертах механизм работы графического приложения. На
рис.~\ref{fig:gui} изображено как происходит взаимодействие между элементами
графического приложения и пользователем.

\begin{figure}
	\centering
	\input{schemes/gui.tex}\\
	\caption{Взаимодействие элементов ГИП и пользователя}\label{fig:gui}
\end{figure}

Исходя из данной упрощенной схемы можно предложить еще одно способ добавить
функциональность — создание события от графической библиотеки, которое будет
передано приложению.

\subsection{Механизм подмены функций}

При запуске приложения загрузчик получает из приложения список всех используемых
динамических библиотек, загружает их в память. Затем получает адреса всех
экспортированных функций динамической библиотеки и сохраняет их для последующего
вызова.

Загрузчик ld, который используется в Linux и FreeBSD позволяет загружать
дополнительные динамические библиотеки, кроме тех, кто запрашивает приложение.
Эта дополнительная библиотека загружается первее всех остальных, что позволяет
ей подмееять функции из других библиотек. Это происходит потому, что при поиске
адреса определенной функции берется первый подходящий.

\subsection{Способ получения информации об элементах}

Для получения информации об элементах интерфейса можно загрузить специальную
библиотеку, которая будет регистрировать создания, изменения и удаления
элементов интерфейса. Затем собранная информация будет передавать на сервер для
последующей работы.

Также данная библиотека может создавать ложные события по командам, приходящим с
сервера. Таким образом кножно иммитировать нажатия кнопок, открытие меню и т.п.

Пользовательский интерфейс через специальное API сможет получать от сервера
информацию о доступных элементах в текущем приложении. После того, как
пользователь произвел выбор, вызывается специальная функция на стороне сервера,
которая приводит к отправке команды клиенту.

\subsection{Реализация кода для подмены функции}

Для внедрения библиотеки требуется реализовать заглушки для функций Qt, которые
будут вызывать специальный обработчик, а затем продолжать нормальное выполнение
функции. Дополнительную сложность создает то, что библиотека Qt написана на
языке C++, который из-за поддержки классов и перегрузкок функций использует т.н.
«искажение имен» (name mangling). Таким образом чтобы создать такой обработчик
нужно специальным образом сконструировать имя функции исходя из имени класса,
метода, набора параметров и возвращаемого значения.

Создание таких обработчиков является рутинной работой в которой человек легко
может допустить ошибку. Поэтому вместо ручного написания каждого обработчика
нужно написать генератор, который может добавить нужные обработчики имея
минимальный и необходимый набор данных (имя класса, метода и т.д.).

\section{Постановка задачи}

Требуется разработать набор программ, которые в комплексе будут решать следующие
задачи:

\begin{itemize}
	\item запускать целевые приложения в специальном окружении;
	\item собирать информацию о существующих элементах графического приложения;
	\item сохранять информацию о всех запущенных приложениях;
	\item отображать пользователю окно для поиска и выбора элемента;
	\item активировать выбранный пользователем элемент.
\end{itemize}

Исходя из приведенного выше анализа следует, что задачи должны быть сгруппированы
в набор программ. Он должен быть реализован в виде следующих элементов:

\begin{enumerate}
	\item\label{lib} Библиотека для внедрения и сбора информации в конкретном
		приложении.
	\item Приложение для сохранения информации, полученой из нескольких
		приложения с библиотекой из п.\ref{lib}.
	\item Графический интерфейс для запуска приложений и отображения окна
		палитры комманд.
\end{enumerate}

\section{Архитектура приложения}

Подходящая архитектура для такой задачи была предложена мной в одной из прошлых
работ\cite{polshakovinject}. На рис.~\ref{fig:arch} изображена схема
взаимодействия данного комплекса программ. На схеме изображены следующие
действия:
\begin{enumerate}
    \item Перехват функции создания элемента интерфейса
    \item Оповещение о создании элемента
    \item Вызов оригинальной функции графической библиотеки
    \item Отображение элемента управления
    \item Передача информации об элементе приложению управления
    \item Отображение палитры команд
    \item Выбор команды
    \item Вызов функции для выполнения команды
    \item Передача команды к выполнению
    \item Вызов функции активации окна целевого приложения
    \item Активация окна
    \item Перехват функции обработки события
    \item Вызов функции обработки события
    \item Вызов функции для выполнения команды
    \item Выполнение команды
\end{enumerate}

\begin{figure}
	\centering
	\input{schemes/arch} \\
	\caption{Общий обзор архитектуры}\label{fig:arch}
\end{figure}

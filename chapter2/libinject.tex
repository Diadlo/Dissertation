\section{Реализация библиотеки для внедрения}

Библиотека, которая будет использоваться для сбора информации, должна
реализовывать часть функций аналогично библиотеке Qt и выполнять следующие
функции:

\begin{itemize}
    \item выполнять регистрацию приложения;
    \item фиксировать создание объектов (в Qt элементы ГИП называются
        виджетами);
    \item фиксировать смену описания объекта;
    \item фиксировать перемещение элементов между окнами;
    \item фиксировать удаление объектов;
    \item активировать элемент по команде.
\end{itemize}

\subsection{Регистрация приложения}

Регистрация приложения должна происходить до создания первого объекта, но
универсального метода, который вызывался бы в самом начале и был бы всегда
доступен для переопределения, к сожалению, нет. Поэтому каждая функция-обертка
в начале проверяет, была ли проведена инициализация. И если нет, то
проводит ее, создавая сокет для получения команд от сервера и посылая ему
команду регистрации текущего приложения.

\subsection{Создание объекта}

В рамках данной работы была реализована система регистрация создания флажков
(\code{QCheckBox}), кнопок (\code{QPushButton}) и «действий» (\code{QAction}).
«Действия» в Qt это абстракция именованной команды, которая может быть
использована в ГИП\cite{qaction}. Например, они применяются в главном меню, в
контекстном меню, в качестве обработчиков горячих клавиш и т.п.

Создание объектов всегда происходит через вызов конструкторов классов. Не все
конструкторы позволяют указывать текст описания элемента. Поэтому для реализации
более общего случая конструкторы с указанием текста рассматриваются как
выполнение двух действий: создание объекта и установка текста.

\subsection{Смена описания}

Почти все виджеты в Qt позволяют менять связанный с ними текст (надпись на
кнопке, название пункта меню и т.п.) во время исполнения. Для всех указанных
выше типов был переопределен метод \code{setText}. При его вызове, клиент
посылает на сервер команду установки текста элемента.

\subsection{Перемещение элементов между окнами}

Qt не имеет доступного для переопределения метода, который позволял бы
отслеживать перемещения объекта. Поэтому в библиотеке пришлось переопределить
метод \code{QWidget::event}. Он вызывается при всех событиях, на которые должен
отреагировать хотя бы один виджет. А фиксация изменения окна у элемента,
происходит в два этапа:

\begin{enumerate}
  \item Получить список всех окон.
  \item Для каждого окна проверить все его дочерние элементы.
\end{enumerate}

Qt использует отличные от X11 понятия «окна». Так, например, элемент может быть
отображен без явного создания соответствующего окна. Тогда на уровне Qt будет
просто виджет, а на уровне X11 --- окно. Поэтому отдельной задачей является
получение списка всех окон в терминах X11. Таковыми являются все виджеты
верхнего уровня, у которых нет родителя.

%\begin{algorithm}[H]
%  окна = пустойСписок()
%  \ForEach{виджет}{Приложение::виджетыВерхнегоУровня()}{
%    \If{виджет.родитель == NULL}{
%      \Continue
%    }
%
%    \If{окна.содержит(виджет)}{
%      \Continue
%    }
%
%    окна.добавить(виджет)\;
%  }
%  %\caption{Определение смены окна}
%\end{algorithm}

Затем запускается рекурсивный алгоритм, который проверяет, есть ли среди
дочерних элементов новые.

\begin{algorithm}[H]
  \Fn{привязатьЭлементКОкну(элемент, новоеОкно)}{
    староеОкно = окноЭлемента[элемент]\;
    \If{староеОкно == NULL или староеОкно != новоеОкно}{
      послатьКомандуСменыОкна(элемент, новоеОкно)\;
      окноЭлемента[элемент] = новоеОкно\;
    }

    \ForEach{дочернийЭлемент в элемент.подэлементы()}{
      привязатьЭлементКОкну(дочернийЭлемент, новоеОкно)\;
    }
  }
  %\caption{Рекурсивное обновление элементов окна}
\end{algorithm}

Такой метод не слишком оптимален. В рамках улучшения данного решения стоит
поискать возможность усовершенствовать его.

\subsection{Удаление элементов}

В текущей реализации элемент считается недоступным после его удаления из памяти
(т.е. при вызове деструктора), но для удобства работы правильнее было бы
обрабатывать события скрытия и отображения элемента.

\subsection{Активация по команде}

Как было указано в моей прошлой работе\cite{polshakovinject}, библиотека не
может выступать инициатором действия, она в состоянии только реагировать на
события. Поэтому для активации элемента требуется событие, которое, например,
посылает сервер. В текущей реализации была выбрана функция обработки событий как
наиболее часто вызываемая. Именно в ней проверяется наличие команды активации.

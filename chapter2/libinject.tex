\section{Реализация библиотеки для внедрения}

Библиотека, которая будет использоваться для сбора информации, должна
реализовывать часть функций аналогично библиотеке Qt и выполнять следующие
функции:

\begin{itemize}
    \item выполнять регистрацию приложения;
    \item фиксировать создание объектов (в Qt элементы ГИП называются
        виджетами);
    \item фиксировать смену описания объекта;
    \item фиксировать перемещение элементов между окнами;
    \item фиксировать удаление объектов;
    \item активировать элемент по команде.
\end{itemize}

\subsection{Регистрация приложения}

Регистрация приложения должна происходить до создания первого объекта, но
универсального метода, который вызывался бы в самом начале и был бы всегда
доступен для переопределения, к сожалению, нет. Поэтому каждая функция-обертка
в начале проверяет, была ли проведена инициализация. И если нет, то
проводит ее, создавая сокет для получения команд от сервера и посылая ему
команду регистрации текущего приложения.

\subsection{Создание объекта}

В рамках данной работы была реализована система регистрация создания флажков
(\code{QCheckBox}), кнопок (\code{QPushButton}) и «действий» (\code{QAction}).
«Действия» в Qt это абстракция именованной команды, которая может быть
использована в ГИП\cite{qaction}. Например, они применяются в главном меню, в
контекстном меню, в качестве обработчиков горячих клавиш и т.п.

Создание объектов всегда происходит через вызов конструкторов классов. Не все
конструкторы позволяют указывать текст описания элемента. Поэтому для реализации
более общего случая конструкторы с указанием текста рассматриваются как
выполнение двух действий: создание объекта и установка текста.

\subsection{Смена описания}

Почти все виджеты в Qt позволяют менять связанный с ними текст (надпись на
кнопке, название пункта меню и т.п.) во время исполнения. Для всех указанных
выше типов был переопределен метод \code{setText}. При его вызове, клиент
посылает на сервер команду установки текста элемента.

\subsection{Перемещение элементов между окнами}

Qt не имеет доступного для переопределения метода, который позволял бы
отслеживать перемещения объекта. Поэтому в библиотеке пришлось переопределить
метод \code{QWidget::event}. Он вызывается при всех событиях, на которые должен
отреагировать хотя бы один виджет. А фиксация изменения окна у элемента,
происходит в два этапа:

\begin{enumerate}
  \item Получить список всех окон.
  \item Для каждого окна проверить все его дочерние элементы.
\end{enumerate}

Qt использует отличные от X11 понятия «окна». Так, например, элемент может быть
отображен без явного создания соответствующего окна. Тогда на уровне Qt будет
просто виджет, а на уровне X11 --- окно. Поэтому отдельной задачей является
получение списка всех окон в терминах X11. Таковыми являются все виджеты
верхнего уровня, у которых нет родителя.

%\begin{algorithm}[H]
%  окна = пустойСписок()
%  \ForEach{виджет}{Приложение::виджетыВерхнегоУровня()}{
%    \If{виджет.родитель == NULL}{
%      \Continue
%    }
%
%    \If{окна.содержит(виджет)}{
%      \Continue
%    }
%
%    окна.добавить(виджет)\;
%  }
%  %\caption{Определение смены окна}
%\end{algorithm}

Затем запускается рекурсивный алгоритм, который проверяет, есть ли среди
дочерних элементов новые.

\begin{algorithm}[H]
  \Fn{привязатьЭлементКОкну(элемент, новоеОкно)}{
    староеОкно = окноЭлемента[элемент]\;
    \If{староеОкно == NULL или староеОкно != новоеОкно}{
      послатьКомандуСменыОкна(элемент, новоеОкно)\;
      окноЭлемента[элемент] = новоеОкно\;
    }

    \ForEach{дочернийЭлемент в элемент.подэлементы()}{
      привязатьЭлементКОкну(дочернийЭлемент, новоеОкно)\;
    }
  }
  %\caption{Рекурсивное обновление элементов окна}
\end{algorithm}

Такой метод не слишком оптимален. В рамках улучшения данного решения стоит
поискать возможность усовершенствовать его.

\subsection{Удаление элементов}

В текущей реализации элемент считается недоступным после его удаления из памяти
(т.е. при вызове деструктора), но для удобства работы правильнее было бы
обрабатывать события скрытия и отображения элемента.

\subsection{Активация по команде}

Как было указано в моей прошлой работе\cite{polshakovinject}, библиотека не
может выступать инициатором действия, она в состоянии только реагировать на
события. Поэтому для активации элемента требуется событие, которое, например,
посылает сервер. В текущей реализации была выбрана функция обработки событий как
наиболее часто вызываемая. Именно в ней проверяется наличие команды активации.

\subsection{Устройство библиотеки}

Библиотека состоит из функций. Они делятся на два типа: обработчики и 
вспомогательные. Для того, чтобы сохранять состояния между вызовами функций 
приходится использовать глобальные переменные.

\subsubsection{Данные в библиотеке}

\begin{itemize}
	\item \code{g\_server} "--- сокет для отправки команд на сервер;
	\item \code{g\_client} "--- сокет для получения команд от сервер;
	\item \code{g\_handlers} "--- ассоциативный массив, ставящий каждому объекту
	интерфейса в соответствие функцию активации. Это требуется для того, чтобы
	на этапе получения команды "<activate"> от сервера, библиотеке не 
	приходилось проверять все возможные типы объекта;
	\item \code{g\_widgetWindow} "--- ассоциативный массив, ставящий каждому
	объекту интерфейса в соответствие окно, к которому объект принадлежит.
\end{itemize}

\subsection{Функции обработчики}

\begin{itemize}
	\item \code{checkEvent} "--- функция обработки событий. Заменяет собой 
	\code{QWidget\allowbreak ::\allowbreak event}. Посылает серверу команду о том, что окно
	активировано, когда в качестве параметра приходит
	\code{QEvent::WindowActivate};
	\item \code{registerButton}, \code{registerCheckbox} "--- функция обработки
	создания кнопки и флажка. Заменяет собой конструкторы классов \code{QPush\-Button} и \code{QCheckBox}. Посылает серверу команду о
	создании нового виджета.
	\item \code{registerAction}, \code{registerActionWithIcon} "--- функция
	обработки создания кнопки. Заменяет собой два перегруженных конструктора
	класса \code{QAction}. Посылает серверу команду о создании нового события.
	\item \code{updateButtonText}, \code{updateActionText} "--- функция обработки
	изменения текста. Заменяют собой функции \code{setText} классов
	\code{QPush\-Button} и \code{QAction}.
\end{itemize}

\subsubsection{Вспомогательные функции}

\begin{itemize}
	\item \code{updateWidgetsWindowsRecursive} "--- функция рекурсивного обхода
	объектов (на основе механизма владения, предоставленном Qt).
	\item \code{updateWidgetWindow} "--- функция для проверки изменения и первой 
	установки родительского окна у элемента.
	\item \code{doUpdateWidgetWindow} "--- функция для отправки серверу 
	информациио привязке виджета к окну.

	\item \code{activateWidget} "--- функция обработки команды активации 
	элемента. Проверяет наличие данных в сокете, разбирает команду и вызывает функцию активации основываясь на данных из \code{g\_handlers}.
	
	\item \code{setWidgetText} "--- функция для отправки серверу команды
	для информирования об изменении текст виджета.
	\item \code{initInject} "--- функция инициализации библиотеки. Подключается
	к сокету сервера, создает свой сокет через который будет получать команды, 
	посылает серверу команду, в которой сообщает свой идентификатор процесса
	и адрес своего сокета.
	
	\item \code{getXProperty} "--- функция для получения свойства окна из
	графической системы Х11. В качестве параметра принимает дескриптор экрана,
	идентификатор окна и имя свойства. Возвращает указатель на массив данных,
	представляющих собой значение свойства.
	\item \code{getLongProperty} "--- функция для получения значения свойства,
	которое представимо 4я байтами.

	\item \code{getWindowId} "--- функция получения идентификатора текущего
	активного окна. Предполагается, что будет использоваться при получении
	события активации окна, поэтому будет возвращать идентификатор текущего окна.
	\item \code{getPid} "--- функция получения идентификатора процесса
	прикладного приложения в который было произведено внедрение.

	\item \code{sendData} "--- функция для отправки "<сырых"> данных.
	\item \code{sendString} "--- функция для отправки строк. В соответствии с
	протоколом, сначала передается длина строки, потом строка в кодировке
	ASCII.
\end{itemize}

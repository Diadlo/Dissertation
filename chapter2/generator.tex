\section{Реализация генератора кода}

Файл, который подается на вход генератору должен представлять собой готовый к
использованию исходный код, за исключением функций-оберток. Функции обертки
должны быть сопоставлены с функциями-обработчиками. Для добавления возможности
такого сопоставления было принято решение добавить специальные комментарии,
которые состоят из:

\begin{enumerate}
	\item Опорного элемента (\code{//method}). Он требуется для того, чтобы
		отличать описательные комментарии от обычных.
	\item Сигнатура метода в которой не указываются имена переменных.
	\item Разделитель сигнатуры и названия функции-обработчика. В качестве
		разделителя выступает стрелка \code{->}.
	\item Название функции-обработчика.
\end{enumerate}

Пример комментария: \code{//method bool QWidget::event(QEvent*) -> checkEvent}

Вместо каждого такого комментария генератор подставляет код функции, реализующий
следующий алгоритм:

\begin{algorithm}[H]
  \Fn{методБиблиотеки({$a$, $b$, $c$})}{
    \If{реальнаяФункция == NULL}{
      реальнаяФункция = следующийСимвол("методБиблиотеки")\;
    }

    \If{инициализацияУспешна()}{
      функцияОбработчик($a$, $b$, $c$)\;
    }
    \KwRet\ реальнаяФункция($a$, $b$, $c$);
  }
  %\caption{Общий вид алгоритма подмены функции}
\end{algorithm}

Если бы этого было достаточно, то для подстановки можно было использовать
макросы из языка Си. Однако сложность заключается в получении имени функции для
подмены. Это связано с тем, что символы в исполняемом файле должны представлять
собой просто идентификатор, который не предусматривает сам по себе типы
параметров, возвращаемых значений, имена классов и т.п.
% Тут можно добавить про то, почему каждый из этих пунктов нужен.
Стандарт языка С++ не говорит, как именно должно происходить данное
преобразование, поэтому это будет зависеть от реализации. Существуют стандарты
ABI (application binary interface, двоичный интерфейс приложения), которые
определяют как должно происходить данное преобразование. Это позволяет
библиотекам, собранным разными компиляторами с одним стандартом ABI, работать
друг с другом. Для Linux одним из наиболее распространенных стандартов ABI
является Itanium\cite{itaniumabi}.

Т.к. в рамках данной работы не нужно генерировать имена с использованием
пространств имен, виртуальных таблиц и т.п., была реализована только часть
стандарта, описывающая получение имени функции и некоторых типов.

\begin{minted}{text}
<имя-функции> ::= _Z <имя>
<имя> ::= <вложенное-имя> <параметры-функции>
<вложенное-имя> ::= N <префикс> <явное-имя> E
<префикс> ::= <префикс> <явное-имя>
          ::= <явное-имя>
<явное-имя> ::= <имя-из-исходного-кода>
            ::= <конструктор-или-деструктор>
<имя-из-исходного-кода> ::= <длина-идентификатора> <идентификатор>
<конструктор-или-деструктор> ::= С1
                             ::= D1

<параметры-функции> ::= <тип>
                    ::= <тип> <параметры-функции>
<тип> ::= <встроенный-тип>
      ::= <квалифицированный-тип>
      ::= <имя-класса-или-перечисления>

<встроенный-тип> ::= v # void
                 ::= i # int
                 ::= c # char
                 ::= b # bool

<квалифицированный-тип> ::= <квалификатор> <тип>
<квалификатор> ::= K # const
               ::= R # reference

<имя-класса-или-перечисления> ::= <имя>
\end{minted}


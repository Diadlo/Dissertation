\chapter{Реализация}

\section{Средства реализации}

\begin{itemize}
	\item Язык программирования С для написания внедряемой библиотеки;
	\item Язык программирования Python для написания графического интерфейса и
		генератора кода;
	\item Система сборки CMake.
	\item Система управления версиями Git.
\end{itemize}

В данной работе используются два языка программирования по следующим причинам:

\begin{itemize}
	\item Язык С предоставляет низкоуровневый интерфейс, который позволяет
		переопределить нужные функции во внедряемой библиотеке и в то же время
		без особой сложности в нем можно реализовать передачу данных в сокет.
	\item Язык Python, напротив, позволяет писать высокоуровневый код, что
		упрощает разработку прикладных приложений (в частности приложений с
		графическим интерфейсом).
\end{itemize}

\section{Требования к программному и аппаратному обеспечению}

Приложение предназначено для использования на IBM PC-совместимых компьютерах с
операционной системой Linux.

Работы приложения требуются:

\begin{itemize}
	\item аппаратное обеспечение согласно требованиям ОС;
	\item ОЗУ не менее 1 ГБ;
	\item 1 Гб свободного места;
	\item наличие интерпритатора Python.
\end{itemize}

Требования к целевому приложению:

\begin{itemize}
	\item приложение должно использовать графическую библиотеку Qt;
	\item должна быть произведена динамическая линковка с данной библиотекой.
\end{itemize}

\section{Генератор кода}

Файл, который подается на вход генератору должен представлять собой готовый к
использованию исходный код, за исключением функций-оберток. Функции обертки
должны быть сопоставлены с функциями-обработчиками. Для добавления возможности
такого сопоставления было принято решение добавить специальные комментарии,
которые состоят из:

\begin{enumerate}
	\item Опорного элемента (\code{//method}). Он требуется для того, чтобы
		отличать описательные комментарии от обычных.
	\item Сигнатура метода в которой не указываются имена переменных.
	\item Разделитель сигнатуры и названия функции-обработчика. В качестве
		разделителя выступает стрелка \code{->}.
	\item Название функции-обработчика.
\end{enumerate}

Пример комментария: \code{//method bool QWidget::event(QEvent*) -> checkEvent}

Вместо каждого такого комментария генератор подставляет код функции, реализующий
следующий алгоритм:

\begin{algorithm}[H]
  \Fn{методБиблиотеки({$a$, $b$, $c$})}{
    \If{реальнаяФункция == NULL}{
      реальнаяФункция = следующийСимвол("методБиблиотеки")\;
    }

    \If{инициализацияУспешна()}{
      функцияОбработчик($a$, $b$, $c$)\;
    }
    \KwRet\ реальнаяФункция($a$, $b$, $c$);
  }
  %\caption{Общий вид алгоритма подмены функции}
\end{algorithm}

Но если бы этого было достаточно, то для подставновки можно было использовать
макросы из языка Си. Однако сложность заключается в получении имени функции для
подмены. Это связано с тем, что символы в исполняемом файле должны представлять
собой просто идентификатор, который не предусматривает сам по себе типы
параметров, возвращаемых значений, имена классов и т.п.
% Тут можно добавить про то, почему каждый из этих пунктов нужен.
Однако вся эта информация должна быть сохранена. Стандарт языка С++ не говорит,
как именно должно происходить данное преобразование, поэтому это будет зависить
от реализации. Однако существуют стандарты ABI (application binary interface,
двоичный интерфейс приложения), которые определяют как должно происходить данное
преобразование. Это позволяет библиотекам, собраным разными компиляторами с
одним стандартом ABI, работать друг с другом. Для Linux одним из неиболее
распространенных стандартов ABI является Itanium\cite{itaniumabi}

Т.к. в рамках данной работы не нужно генерировать имена с использованием
пространств имен, виртуальных таблиц и т.п., была реализована только часть
стандарта, описывающая получение имени функции и некоторых типов.

\begin{minted}{text}
<имя-функции> ::= _Z <имя>
<имя> ::= <вложенное-имя> <параметры-функции>
<вложенное-имя> ::= N <префикс> <явное-имя> E
<префикс> ::= <префикс> <явное-имя>
          ::= <явное-имя>
<явное-имя> ::= <имя-из-исходного-кода>
            ::= <конструктор-или-деструктор>
<имя-из-исходного-кода> ::= <длина-идентифкатора> <идентификатор>
<конструктор-или-деструктор> ::= С1
                             ::= D1

<параметры-функции> ::= <тип>
                    ::= <тип> <параметры-функции>
<тип> ::= <встроенный-тип>
      ::= <квалифицированный-тип>
      ::= <имя-класса-или-перечисления>

<встроенный-тип> ::= v # void
                 ::= i # int
                 ::= c # char
                 ::= b # bool

<квалифицированный-тип> ::= <квалификатор> <тип>
<квалификатор> ::= K # const
               ::= R # reference

<имя-класса-или-перечисления> ::= <имя>
\end{minted}

\section{}

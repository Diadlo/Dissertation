\chapter{Анализ задачи}

\section{Общий анализ}

Система управления должна позволять контролировать множество приложений. Для её
реализации лучше всего подходит клиент-серверная архитектура. Для каждого
целевого приложения будет запускаться отдельный клиент, который будет заниматься
сбором информации об элементах управления и передавать её на сервер.

В качестве сервера будет выступать приложение, которое запускает целевые
приложения вместе с клиентами. После этого сервер принимает входяще соединение
от клиента и отображающее окно поиска элемента для текущего активного окна.

Для удобной работы окно поиска должно отображаться окно поверх работающего
приложения. И в нем должен производится нечеткий поиск.

В операционной системе Linux существует две основных графических библиотеки: GTK
и Qt. Библиотека GTK, начиная с третьей версии предоставляет возможность
запускать приложения с дополнительными модулями, которые могут расширять
функциональность приложения. Этим воспользовались разработчики библиотеки
Plotinus, реализовав возможность добавления палитры команд в любое приложение,
использующее GTK3.

\subsection{Реализация библиотеки}

Для внедрения библиотеки требуется реализовать заглушки для функций Qt, которые
будут вызывать специальный обработчик, а затем продолжать нормальное выполнение
функции. Дополнительную сложность создает то, что библиотека Qt написана на
языке C++, который из-за поддержки классов и перегрузкок функций использует т.н.
<<искажение имен>> (name mangling). Таким образом чтобы создать такой обработчик
нужно специальным образом сконструировать имя функции исходя из имени класса,
метода, набора параметров и возвращаемого значения.

Создание таких обработчиков является рутинной работой в которой человек легко
может допустить ошибку. Поэтому вместо ручного написания каждого обработчика
нужно написать генератор, который может добавить нужные обработчики имя
минимальный и необходимый набор данных (имя класса, метода и т.д.).

\subsection{Способ получения информации об элементах}

В общем случае Qt не предоставляет возможности добавить сторонний модуль в
существующую программу, поэтому для этого придется использовать средство
системы. А именно --- инъекцию динамической библиотеки.

В операционной системе Linux есть специальная переменная окружения, которая
говорит загрузчику, чтобы определенная библиотека была загружена раньше других.
Таким образом  операционная система в первую очередь загружает указанную
библиотеку, что передает вызывающей программе указатели на функции загруженной
библиотеки. Такой механизм позволяет регистрировать вызовы различных функций.

Для получения информации об элементах интерфейса можно загрузить специальную
библиотеку, которая будет регистрировать создания, изменения и удаления
элементов интерфейса. Затем собранная информация будет передавать на сервер для
последующей работы.

Пользовательский интерфейс через специальное API получает от сервера информацию
о доступных элементах в текущем приложении. После того, как пользователь
произвел выбор, вызывается специальная функция на стороне сервера, которая
приводит к отправке команды клиенту.

Клиент на своей стороне реализует возможность активации элемента интерфейса
(нажатие кнопки, выбор меню и т.п.).

\section{Постановка задачи}

Разработать набор программ, которые в комплексе будут решать следующие задачи:

\begin{itemize}
	\item запускать целевые приложения в специальном окружении;
	\item собирать информацию о существующих элементах графического приложения;
	\item сохранять информацию о всех запущенных приложениях;
	\item отображать пользователю окно для поиска и выбора элемента;
	\item активировать выбранный пользователем элемент.
\end{itemize}

Этот набор программ должен быть реализован в виде следующих элементов:

\begin{enumerate}
	\item\label{lib} Библиотека для инъекции и сбора информации в конкретном
		приложении.
	\item Приложение для сохранения информации, полученой из нескольких
		приложения с библиотекой из п.\ref{lib}.
	\item Графический интерфейс для запуска приложений.
\end{enumerate}
